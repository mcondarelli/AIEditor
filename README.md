# AIEditor

## Purpose

This project stems from two interests:

1. I like to write novels and I feel none of the currently existing Markup languages nor editors is really suited to the
   task.
2. My mother language is Italian and I never found a syntactic checker worth a penny in my language (IMHO LanguageTool
   is utter crap) so I thought about using some AI to generate meaningful reports.

## Status

This is currently WIP I use to polish a long (~900 pages) novel I'm writing and, while already useful, lacks a lot of
features I'll implement on a "when needed" basis.

## Architecture

### Data

Actual data is stored locally in a `SQLite3` database and is structured in:

- Books
    - Parts
        - Chapters
            - Scenes
- Characters
- Places
- Objects

Each of those has associated name, text, commentary and translation.

- Name is the (translatable) name or title of the object.
- Text is the actual content which may or may not be part of the final book (text of the scene is the actual content of
  the book while a chapter may have a short outline and a character a biography).
- Commentary is supposed to be generated by AI and should act as an encompassing review of the text at grammatical and
  stylistic level.
- Translation is supposed to be automatically generated and then reviewed.

### Markup

Text markup is very simple as in books there is little use for lists, bullets, tables and similar things, OTOH there is
a strong need for direct speech handling, possibly nested.

Line breaks are preserved, this means a line may be very long if i want system to handle wrapping automatically; in
editor Soft wrap is needed.

Line breaks do **not** start a new paragraph as often in text there's the need to restart the line without the visuals (
larger interline or indentation) proper of paragraph break.

Paragraph break is represented by an empty line (like in Markdown and other markup languages).

In my markup there are just 4 "constructs":

- Bold: `@b{`text to be displayed in bold`}q@`
- Italics: `@e{`text to be displayed in italics`}e@`
- Normal quotes: `@q{`text to be wrapped in quotes, possibly nested`}q@`
- Attributed quotes `@Q[`name`]{`text wrapped in quotes explicitly attributed to `name` speaker`}Q@`

I didn't find use for any other construct.

All these constructs are specifically restricted to be fully on a line, i.e.: at end-of-line all constructs must be
closed.

There actually *are* cases where a multiline construct could be useful, but I didn't think actually worthwhile the
hassle to implement them.

Constructs may nest but not partially overlap, much as HTML tags.

### AI queries

There are several possible source of commentary and several different queries (i.e.: "prompts") possible.

#### sources:

- Semantic database: convert all writing into a **dense vector embedding** capable of capturing semantic of plot and
  queryable about themes, character interactions, plot points and similar chores.
- local: AI hosted locally; cost-effective but requires rather powerful hardware; can be used to do style analysis at
  scene or, at most, chapter level.
- commercial: interface to query large AI models (DeepSeek, ChatGPT, Mistral, etc.) which require a (very possibly
  costly) account but could analyze the whole text and provide fine-graded coherence analysis.

#### queries:

- TBD

## Structure

Program is composed by three main sections:

- a top navigation bar with a kind of breadcrumb making it easy to move from a scene to another.
- a left pane with the actual Scene Editor
- a right multipurpose pane where there may be:
    - in writing mode:
        - description of current chapter
        - description of current scene
        - list of characters, places and objects named in the chapter, possibly with some info
    - in review mode:
        - AI-generated summary
        - AI-generated metrics
    - in translation mode:
        - original
    - in transfer mode:
        - parameters for export in `LaTeX`/`PDF`
        - parameters for export in `Sigil`/`EPUB`

##### TODO List

1. Structure
    1. Main Window
        1. [ ]  Dialog to change default visuals
            1. [ ] at least default font and pitch
            2. [ ] possibly full theming
        2. [ ] move [Prev] and [Next] buttons top bar on the sides of crumb bar, something like:
           
           `[Prev] - [  Book  v][  Part  v][Chapter v][  Scene v] - [Next]`
        3. [ ] Use splitter to separate left(edit) and right(info) panes
        4. [ ] Splitter should be completely collapsable to allow undisturbed edit
        5. [ ] Use Tab widget on right pane to hold different kind of information, at least:
            1. [ ] Edit info (chapter and scene summary, character/place/object summary)
            2. [ ] Review info (chapter and scene commentary)
            3. [ ] Translation (original text, AI tips)
            4. [ ] Export (TBD) 
    2. SceneEdit
        1. [ ] highlighting of character, object and place names.
        2. [ ] context menu to mark word as name.
        3. [ ] spellcheck (intelligent? is it fast enough?) with squiggly underline.
2. AI Requests
    1. [ ] Scene-level commentary (current scene and batch)
    2. [ ] Scene-level export to semantic database (current scene and batch)
    3. [ ] Scene-level  summary (from SD)
    4. [ ] Chapter-level summary (from SD)
    5. [ ] Chapter-level commentary with style and coherence test
    6. [ ] Character coherence
    7. [ ] Book-level commentary with style and coherence test
